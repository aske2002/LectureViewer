//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IUsersClient {
    postApiUsersLogin(login: LoginRequest, useCookies?: boolean | null | undefined, useSessionCookies?: boolean | null | undefined): Promise<AccessTokenResponse>;
    postApiUsersRefresh(refreshRequest: RefreshRequest): Promise<AccessTokenResponse>;
    getApiUsersConfirmEmail(userId: string, code: string, changedEmail?: string | null | undefined): Promise<void>;
    postApiUsersResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest): Promise<void>;
    postApiUsersForgotPassword(resetRequest: ForgotPasswordRequest): Promise<void>;
    postApiUsersResetPassword(resetRequest: ResetPasswordRequest): Promise<void>;
    postApiUsersManage2fa(tfaRequest: TwoFactorRequest): Promise<TwoFactorResponse>;
    postApiUsersManageInfo(infoRequest: InfoRequest): Promise<InfoResponse>;
    getInfo(): Promise<UserInfoVm>;
    register(command: CreateUserCommand): Promise<void>;
    signOut(): Promise<void>;
}

export class UsersClient implements IUsersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    postApiUsersLogin(login: LoginRequest, useCookies?: boolean | null | undefined, useSessionCookies?: boolean | null | undefined, cancelToken?: CancelToken): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Users/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostApiUsersLogin(_response);
        });
    }

    protected processPostApiUsersLogin(response: AxiosResponse): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessTokenResponse.fromJS(resultData200);
            return Promise.resolve<AccessTokenResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    postApiUsersRefresh(refreshRequest: RefreshRequest, cancelToken?: CancelToken): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Users/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostApiUsersRefresh(_response);
        });
    }

    protected processPostApiUsersRefresh(response: AxiosResponse): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessTokenResponse.fromJS(resultData200);
            return Promise.resolve<AccessTokenResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    getApiUsersConfirmEmail(userId: string, code: string, changedEmail?: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/confirmEmail?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApiUsersConfirmEmail(_response);
        });
    }

    protected processGetApiUsersConfirmEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    postApiUsersResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostApiUsersResendConfirmationEmail(_response);
        });
    }

    protected processPostApiUsersResendConfirmationEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    postApiUsersForgotPassword(resetRequest: ForgotPasswordRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostApiUsersForgotPassword(_response);
        });
    }

    protected processPostApiUsersForgotPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    postApiUsersResetPassword(resetRequest: ResetPasswordRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostApiUsersResetPassword(_response);
        });
    }

    protected processPostApiUsersResetPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    postApiUsersManage2fa(tfaRequest: TwoFactorRequest, cancelToken?: CancelToken): Promise<TwoFactorResponse> {
        let url_ = this.baseUrl + "/api/Users/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tfaRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostApiUsersManage2fa(_response);
        });
    }

    protected processPostApiUsersManage2fa(response: AxiosResponse): Promise<TwoFactorResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TwoFactorResponse.fromJS(resultData200);
            return Promise.resolve<TwoFactorResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TwoFactorResponse>(null as any);
    }

    postApiUsersManageInfo(infoRequest: InfoRequest, cancelToken?: CancelToken): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/api/Users/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(infoRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostApiUsersManageInfo(_response);
        });
    }

    protected processPostApiUsersManageInfo(response: AxiosResponse): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InfoResponse.fromJS(resultData200);
            return Promise.resolve<InfoResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("A server side error occurred.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    getInfo( cancelToken?: CancelToken): Promise<UserInfoVm> {
        let url_ = this.baseUrl + "/api/Users/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInfo(_response);
        });
    }

    protected processGetInfo(response: AxiosResponse): Promise<UserInfoVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserInfoVm.fromJS(resultData200);
            return Promise.resolve<UserInfoVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserInfoVm>(null as any);
    }

    register(command: CreateUserCommand, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    signOut( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/signout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ICoursesClient {
    listCourses(): Promise<CourseListDto[]>;
    createCourse(command: CreateCourseCommand): Promise<string>;
    enrollInCourse(command: EnrollCourseCommand): Promise<string>;
    getCourseById(courseId: string): Promise<CourseDetailsDto>;
    getCoursePermissions(courseId: string): Promise<CoursePermissionsDto>;
    addLectureToCourse(courseId: string, command: CreateLectureCommand): Promise<string>;
}

export class CoursesClient implements ICoursesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    listCourses( cancelToken?: CancelToken): Promise<CourseListDto[]> {
        let url_ = this.baseUrl + "/api/Courses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListCourses(_response);
        });
    }

    protected processListCourses(response: AxiosResponse): Promise<CourseListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CourseListDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseListDto[]>(null as any);
    }

    createCourse(command: CreateCourseCommand, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/Courses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCourse(_response);
        });
    }

    protected processCreateCourse(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    enrollInCourse(command: EnrollCourseCommand, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/Courses/enroll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEnrollInCourse(_response);
        });
    }

    protected processEnrollInCourse(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getCourseById(courseId: string, cancelToken?: CancelToken): Promise<CourseDetailsDto> {
        let url_ = this.baseUrl + "/api/Courses/{courseId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCourseById(_response);
        });
    }

    protected processGetCourseById(response: AxiosResponse): Promise<CourseDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CourseDetailsDto.fromJS(resultData200);
            return Promise.resolve<CourseDetailsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CourseDetailsDto>(null as any);
    }

    getCoursePermissions(courseId: string, cancelToken?: CancelToken): Promise<CoursePermissionsDto> {
        let url_ = this.baseUrl + "/api/Courses/{courseId}/permissions";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCoursePermissions(_response);
        });
    }

    protected processGetCoursePermissions(response: AxiosResponse): Promise<CoursePermissionsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CoursePermissionsDto.fromJS(resultData200);
            return Promise.resolve<CoursePermissionsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CoursePermissionsDto>(null as any);
    }

    addLectureToCourse(courseId: string, command: CreateLectureCommand, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/Courses/{courseId}/lectures";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddLectureToCourse(_response);
        });
    }

    protected processAddLectureToCourse(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface ILecturesClient {
    getLectureDetails(courseId: string, lectureId: string): Promise<LectureDto>;
    extractTranscriptKeywords(transcriptId: string): Promise<void>;
    getLectureContentStream(courseId: string, lectureId: string, lectureContentId: string, resourceId: string, download?: string | null | undefined): Promise<void>;
    listLectureContents(courseId: string, lectureId: string): Promise<LectureContentListDto>;
    uploadLectureMedia(courseId: string, lectureId: string, name: string, description?: string | null | undefined, isMainContent?: boolean | undefined, file?: FileParameter | undefined): Promise<string>;
    updateLectureContent(courseId: string, command: UpdateLectureContentCommandContent): Promise<LectureContentDto>;
}

export class LecturesClient implements ILecturesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getLectureDetails(courseId: string, lectureId: string, cancelToken?: CancelToken): Promise<LectureDto> {
        let url_ = this.baseUrl + "/api/Lectures/{courseId}/{lectureId}";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        if (lectureId === undefined || lectureId === null)
            throw new Error("The parameter 'lectureId' must be defined.");
        url_ = url_.replace("{lectureId}", encodeURIComponent("" + lectureId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLectureDetails(_response);
        });
    }

    protected processGetLectureDetails(response: AxiosResponse): Promise<LectureDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LectureDto.fromJS(resultData200);
            return Promise.resolve<LectureDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LectureDto>(null as any);
    }

    extractTranscriptKeywords(transcriptId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Lectures/transcripts/{transcriptId}/extract-keywords";
        if (transcriptId === undefined || transcriptId === null)
            throw new Error("The parameter 'transcriptId' must be defined.");
        url_ = url_.replace("{transcriptId}", encodeURIComponent("" + transcriptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExtractTranscriptKeywords(_response);
        });
    }

    protected processExtractTranscriptKeywords(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getLectureContentStream(courseId: string, lectureId: string, lectureContentId: string, resourceId: string, download?: string | null | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Lectures/{courseId}/{lectureId}/contents/{lectureContentId}/{resourceId}?";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        if (lectureId === undefined || lectureId === null)
            throw new Error("The parameter 'lectureId' must be defined.");
        url_ = url_.replace("{lectureId}", encodeURIComponent("" + lectureId));
        if (lectureContentId === undefined || lectureContentId === null)
            throw new Error("The parameter 'lectureContentId' must be defined.");
        url_ = url_.replace("{lectureContentId}", encodeURIComponent("" + lectureContentId));
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (download !== undefined && download !== null)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLectureContentStream(_response);
        });
    }

    protected processGetLectureContentStream(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    listLectureContents(courseId: string, lectureId: string, cancelToken?: CancelToken): Promise<LectureContentListDto> {
        let url_ = this.baseUrl + "/api/Lectures/{courseId}/{lectureId}/contents";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        if (lectureId === undefined || lectureId === null)
            throw new Error("The parameter 'lectureId' must be defined.");
        url_ = url_.replace("{lectureId}", encodeURIComponent("" + lectureId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListLectureContents(_response);
        });
    }

    protected processListLectureContents(response: AxiosResponse): Promise<LectureContentListDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LectureContentListDto.fromJS(resultData200);
            return Promise.resolve<LectureContentListDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LectureContentListDto>(null as any);
    }

    uploadLectureMedia(courseId: string, lectureId: string, name: string, description?: string | null | undefined, isMainContent?: boolean | undefined, file?: FileParameter | undefined, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/Lectures/{courseId}/{lectureId}/media?";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        if (lectureId === undefined || lectureId === null)
            throw new Error("The parameter 'lectureId' must be defined.");
        url_ = url_.replace("{lectureId}", encodeURIComponent("" + lectureId));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        if (isMainContent === null)
            throw new Error("The parameter 'isMainContent' cannot be null.");
        else if (isMainContent !== undefined)
            url_ += "isMainContent=" + encodeURIComponent("" + isMainContent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadLectureMedia(_response);
        });
    }

    protected processUploadLectureMedia(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    updateLectureContent(courseId: string, command: UpdateLectureContentCommandContent, cancelToken?: CancelToken): Promise<LectureContentDto> {
        let url_ = this.baseUrl + "/api/Lectures/{courseId}/contents";
        if (courseId === undefined || courseId === null)
            throw new Error("The parameter 'courseId' must be defined.");
        url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateLectureContent(_response);
        });
    }

    protected processUpdateLectureContent(response: AxiosResponse): Promise<LectureContentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LectureContentDto.fromJS(resultData200);
            return Promise.resolve<LectureContentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LectureContentDto>(null as any);
    }
}

export interface IResourcesClient {
    listResources(pageNumber: number, pageSize: number): Promise<FilteredListOfResourceResponse>;
    getResourceInfo(resourceId: string): Promise<ResourceResponse>;
    getResourceContent(resourceId: string, fileName: string): Promise<void>;
}

export class ResourcesClient implements IResourcesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    listResources(pageNumber: number, pageSize: number, cancelToken?: CancelToken): Promise<FilteredListOfResourceResponse> {
        let url_ = this.baseUrl + "/api/Resources?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListResources(_response);
        });
    }

    protected processListResources(response: AxiosResponse): Promise<FilteredListOfResourceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilteredListOfResourceResponse.fromJS(resultData200);
            return Promise.resolve<FilteredListOfResourceResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilteredListOfResourceResponse>(null as any);
    }

    getResourceInfo(resourceId: string, cancelToken?: CancelToken): Promise<ResourceResponse> {
        let url_ = this.baseUrl + "/api/Resources/{resourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResourceInfo(_response);
        });
    }

    protected processGetResourceInfo(response: AxiosResponse): Promise<ResourceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResourceResponse.fromJS(resultData200);
            return Promise.resolve<ResourceResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResourceResponse>(null as any);
    }

    getResourceContent(resourceId: string, fileName: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Resources/{resourceId}/{fileName}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResourceContent(_response);
        });
    }

    protected processGetResourceContent(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AccessTokenResponse implements IAccessTokenResponse {
    tokenType!: string;
    accessToken!: string;
    expiresIn!: number;
    refreshToken!: string;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType: string;
    accessToken: string;
    expiresIn: number;
    refreshToken: string;
}

export class LoginRequest implements ILoginRequest {
    email!: string;
    password!: string;
    twoFactorCode!: string | undefined;
    twoFactorRecoveryCode!: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email: string;
    password: string;
    twoFactorCode: string | undefined;
    twoFactorRecoveryCode: string | undefined;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken!: string;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken: string;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email!: string;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email: string;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors!: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors: { [key: string]: string[]; };

    [key: string]: any;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string;
    resetCode!: string;
    newPassword!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string;
    resetCode: string;
    newPassword: string;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey!: string;
    recoveryCodesLeft!: number;
    recoveryCodes!: string[] | undefined;
    isTwoFactorEnabled!: boolean;
    isMachineRemembered!: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey: string;
    recoveryCodesLeft: number;
    recoveryCodes: string[] | undefined;
    isTwoFactorEnabled: boolean;
    isMachineRemembered: boolean;
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable!: boolean | undefined;
    twoFactorCode!: string | undefined;
    resetSharedKey!: boolean;
    resetRecoveryCodes!: boolean;
    forgetMachine!: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable: boolean | undefined;
    twoFactorCode: string | undefined;
    resetSharedKey: boolean;
    resetRecoveryCodes: boolean;
    forgetMachine: boolean;
}

export class InfoResponse implements IInfoResponse {
    email!: string;
    isEmailConfirmed!: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email: string;
    isEmailConfirmed: boolean;
}

export class InfoRequest implements IInfoRequest {
    newEmail!: string | undefined;
    newPassword!: string | undefined;
    oldPassword!: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail: string | undefined;
    newPassword: string | undefined;
    oldPassword: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    email!: string;
    password!: string;
    firstName!: string;
    lastName!: string;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface ICreateUserCommand {
    email: string;
    password: string;
    firstName: string;
    lastName: string;
}

export class UserInfoVm implements IUserInfoVm {
    info!: UserInfoDto;
    roles!: RoleDto[];
    policies!: PolicyDto[];

    constructor(data?: IUserInfoVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.info = _data["info"] ? UserInfoDto.fromJS(_data["info"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["policies"])) {
                this.policies = [] as any;
                for (let item of _data["policies"])
                    this.policies!.push(item);
            }
        }
    }

    static fromJS(data: any): UserInfoVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["info"] = this.info ? this.info.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.policies)) {
            data["policies"] = [];
            for (let item of this.policies)
                data["policies"].push(item);
        }
        return data;
    }
}

export interface IUserInfoVm {
    info: UserInfoDto;
    roles: RoleDto[];
    policies: PolicyDto[];
}

export class UserInfoDto implements IUserInfoDto {
    id!: string;
    userName!: string;
    email!: string;
    firstName!: string;
    lastName!: string;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IUserInfoDto {
    id: string;
    userName: string;
    email: string;
    firstName: string;
    lastName: string;
}

export enum RoleDto {
    Administrator = "Administrator",
    Instructor = "Instructor",
}

export enum PolicyDto {
    CanCreateCourses = "CanCreateCourses",
    DeleteCourse = "DeleteCourse",
    CreateLectures = "CreateLectures",
    EditCourse = "EditCourse",
    ViewCourse = "ViewCourse",
}

export abstract class BaseResponseOfCourseId implements IBaseResponseOfCourseId {
    /** A CourseId identifier */
    id!: string;

    constructor(data?: IBaseResponseOfCourseId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseResponseOfCourseId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponseOfCourseId' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseResponseOfCourseId {
    /** A CourseId identifier */
    id: string;
}

export class CourseListDto extends BaseResponseOfCourseId implements ICourseListDto {
    startDate!: Date;
    endDate!: Date;
    internalIdentifier!: string;
    name!: string;
    description!: string;
    semester!: SemesterDto;
    colour!: Colour;
    instructors!: PublicUser[];
    lecturesCount!: number;

    constructor(data?: ICourseListDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.internalIdentifier = _data["internalIdentifier"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.semester = _data["semester"] ? SemesterDto.fromJS(_data["semester"]) : <any>undefined;
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            if (Array.isArray(_data["instructors"])) {
                this.instructors = [] as any;
                for (let item of _data["instructors"])
                    this.instructors!.push(PublicUser.fromJS(item));
            }
            this.lecturesCount = _data["lecturesCount"];
        }
    }

    static override fromJS(data: any): CourseListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseListDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["internalIdentifier"] = this.internalIdentifier;
        data["name"] = this.name;
        data["description"] = this.description;
        data["semester"] = this.semester ? this.semester.toJSON() : <any>undefined;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        if (Array.isArray(this.instructors)) {
            data["instructors"] = [];
            for (let item of this.instructors)
                data["instructors"].push(item.toJSON());
        }
        data["lecturesCount"] = this.lecturesCount;
        super.toJSON(data);
        return data;
    }
}

export interface ICourseListDto extends IBaseResponseOfCourseId {
    startDate: Date;
    endDate: Date;
    internalIdentifier: string;
    name: string;
    description: string;
    semester: SemesterDto;
    colour: Colour;
    instructors: PublicUser[];
    lecturesCount: number;
}

export abstract class BaseResponseOfSemesterId implements IBaseResponseOfSemesterId {
    /** A SemesterId identifier */
    id!: string;

    constructor(data?: IBaseResponseOfSemesterId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseResponseOfSemesterId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponseOfSemesterId' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseResponseOfSemesterId {
    /** A SemesterId identifier */
    id: string;
}

export class SemesterDto extends BaseResponseOfSemesterId implements ISemesterDto {
    season!: Season;
    year!: number;
    startDate!: Date;
    endDate!: Date;

    constructor(data?: ISemesterDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.season = _data["season"];
            this.year = _data["year"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): SemesterDto {
        data = typeof data === 'object' ? data : {};
        let result = new SemesterDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["season"] = this.season;
        data["year"] = this.year;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISemesterDto extends IBaseResponseOfSemesterId {
    season: Season;
    year: number;
    startDate: Date;
    endDate: Date;
}

export enum Season {
    None = 0,
    Winter = 1,
    Spring = 2,
    Summer = 3,
    Fall = 4,
}

export abstract class ValueObject implements IValueObject {

    constructor(data?: IValueObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ValueObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ValueObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IValueObject {
}

export class Colour extends ValueObject implements IColour {
    code!: string;

    constructor(data?: IColour) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
        }
    }

    static override fromJS(data: any): Colour {
        data = typeof data === 'object' ? data : {};
        let result = new Colour();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        super.toJSON(data);
        return data;
    }
}

export interface IColour extends IValueObject {
    code: string;
}

export class PublicUser implements IPublicUser {
    id!: string;
    userName!: string | undefined;
    firstName!: string;
    lastName!: string;

    constructor(data?: IPublicUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): PublicUser {
        data = typeof data === 'object' ? data : {};
        let result = new PublicUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IPublicUser {
    id: string;
    userName: string | undefined;
    firstName: string;
    lastName: string;
}

export class EnrollCourseCommand implements IEnrollCourseCommand {
    token!: string;
    /** A CourseId identifier */
    courseId!: string;
    user!: ClaimsPrincipal;

    constructor(data?: IEnrollCourseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.courseId = _data["courseId"];
            this.user = _data["user"] ? ClaimsPrincipal.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EnrollCourseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollCourseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["courseId"] = this.courseId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEnrollCourseCommand {
    token: string;
    /** A CourseId identifier */
    courseId: string;
    user: ClaimsPrincipal;
}

export class ClaimsPrincipal implements IClaimsPrincipal {
    claims!: Claim[];
    customSerializationData!: string | undefined;
    identities!: ClaimsIdentity[];
    identity!: IIdentity | undefined;

    constructor(data?: IClaimsPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.customSerializationData = _data["customSerializationData"];
            if (Array.isArray(_data["identities"])) {
                this.identities = [] as any;
                for (let item of _data["identities"])
                    this.identities!.push(ClaimsIdentity.fromJS(item));
            }
            this.identity = _data["identity"] ? IIdentity.fromJS(_data["identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClaimsPrincipal {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["customSerializationData"] = this.customSerializationData;
        if (Array.isArray(this.identities)) {
            data["identities"] = [];
            for (let item of this.identities)
                data["identities"].push(item.toJSON());
        }
        data["identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClaimsPrincipal {
    claims: Claim[];
    customSerializationData: string | undefined;
    identities: ClaimsIdentity[];
    identity: IIdentity | undefined;
}

export class Claim implements IClaim {
    customSerializationData!: string | undefined;
    issuer!: string;
    originalIssuer!: string;
    properties!: { [key: string]: string; };
    subject!: ClaimsIdentity | undefined;
    type!: string;
    value!: string;
    valueType!: string;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customSerializationData = _data["customSerializationData"];
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customSerializationData"] = this.customSerializationData;
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface IClaim {
    customSerializationData: string | undefined;
    issuer: string;
    originalIssuer: string;
    properties: { [key: string]: string; };
    subject: ClaimsIdentity | undefined;
    type: string;
    value: string;
    valueType: string;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType!: string | undefined;
    isAuthenticated!: boolean;
    actor!: ClaimsIdentity | undefined;
    bootstrapContext!: any | undefined;
    claims!: Claim[];
    customSerializationData!: string | undefined;
    externalClaims!: Claim[][];
    label!: string | undefined;
    name!: string | undefined;
    nameClaimType!: string;
    roleClaimType!: string;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.customSerializationData = _data["customSerializationData"];
            if (Array.isArray(_data["externalClaims"])) {
                this.externalClaims = [] as any;
                for (let item of _data["externalClaims"])
                    this.externalClaims!.push(item);
            }
            this.label = _data["label"];
            this.name = _data["name"];
            this.nameClaimType = _data["nameClaimType"];
            this.roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["customSerializationData"] = this.customSerializationData;
        if (Array.isArray(this.externalClaims)) {
            data["externalClaims"] = [];
            for (let item of this.externalClaims)
                data["externalClaims"].push(item);
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType: string | undefined;
    isAuthenticated: boolean;
    actor: ClaimsIdentity | undefined;
    bootstrapContext: any | undefined;
    claims: Claim[];
    customSerializationData: string | undefined;
    externalClaims: Claim[][];
    label: string | undefined;
    name: string | undefined;
    nameClaimType: string;
    roleClaimType: string;
}

export abstract class IIdentity implements IIIdentity {
    name!: string | undefined;
    authenticationType!: string | undefined;
    isAuthenticated!: boolean;

    constructor(data?: IIIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.authenticationType = _data["authenticationType"];
            this.isAuthenticated = _data["isAuthenticated"];
        }
    }

    static fromJS(data: any): IIdentity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IIdentity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        return data;
    }
}

export interface IIIdentity {
    name: string | undefined;
    authenticationType: string | undefined;
    isAuthenticated: boolean;
}

export class CourseDetailsDto extends BaseResponseOfCourseId implements ICourseDetailsDto {
    startDate!: Date;
    endDate!: Date;
    semester!: SemesterDto;
    colour!: Colour;
    internalIdentifier!: string;
    name!: string;
    description!: string;
    lectures!: LectureSimpleDto[];
    instructors!: PublicUser[];

    constructor(data?: ICourseDetailsDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.semester = _data["semester"] ? SemesterDto.fromJS(_data["semester"]) : <any>undefined;
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.internalIdentifier = _data["internalIdentifier"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["lectures"])) {
                this.lectures = [] as any;
                for (let item of _data["lectures"])
                    this.lectures!.push(LectureSimpleDto.fromJS(item));
            }
            if (Array.isArray(_data["instructors"])) {
                this.instructors = [] as any;
                for (let item of _data["instructors"])
                    this.instructors!.push(PublicUser.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): CourseDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDetailsDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["semester"] = this.semester ? this.semester.toJSON() : <any>undefined;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["internalIdentifier"] = this.internalIdentifier;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.lectures)) {
            data["lectures"] = [];
            for (let item of this.lectures)
                data["lectures"].push(item.toJSON());
        }
        if (Array.isArray(this.instructors)) {
            data["instructors"] = [];
            for (let item of this.instructors)
                data["instructors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICourseDetailsDto extends IBaseResponseOfCourseId {
    startDate: Date;
    endDate: Date;
    semester: SemesterDto;
    colour: Colour;
    internalIdentifier: string;
    name: string;
    description: string;
    lectures: LectureSimpleDto[];
    instructors: PublicUser[];
}

export abstract class BaseResponseOfLectureId implements IBaseResponseOfLectureId {
    /** A LectureId identifier */
    id!: string;

    constructor(data?: IBaseResponseOfLectureId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseResponseOfLectureId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponseOfLectureId' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseResponseOfLectureId {
    /** A LectureId identifier */
    id: string;
}

export class LectureSimpleDto extends BaseResponseOfLectureId implements ILectureSimpleDto {
    startDate!: Date;
    endDate!: Date;
    title!: string;
    description!: string;

    constructor(data?: ILectureSimpleDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static override fromJS(data: any): LectureSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new LectureSimpleDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
}

export interface ILectureSimpleDto extends IBaseResponseOfLectureId {
    startDate: Date;
    endDate: Date;
    title: string;
    description: string;
}

export class CoursePermissionsDto implements ICoursePermissionsDto {
    permissions!: CoursePermissionType[];

    constructor(data?: ICoursePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CoursePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoursePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface ICoursePermissionsDto {
    permissions: CoursePermissionType[];
}

export enum CoursePermissionType {
    Delete = "Delete",
    CreateLectures = "CreateLectures",
    UploadCourseContent = "UploadCourseContent",
    Edit = "Edit",
    View = "View",
}

export class CreateCourseCommand implements ICreateCourseCommand {
    name!: string;
    description!: string;
    startDate!: Date;
    endDate!: Date;
    internalIdentifier!: string;
    semesterSeason!: Season;
    semesterYear!: number;

    constructor(data?: ICreateCourseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.internalIdentifier = _data["internalIdentifier"];
            this.semesterSeason = _data["semesterSeason"];
            this.semesterYear = _data["semesterYear"];
        }
    }

    static fromJS(data: any): CreateCourseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCourseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["internalIdentifier"] = this.internalIdentifier;
        data["semesterSeason"] = this.semesterSeason;
        data["semesterYear"] = this.semesterYear;
        return data;
    }
}

export interface ICreateCourseCommand {
    name: string;
    description: string;
    startDate: Date;
    endDate: Date;
    internalIdentifier: string;
    semesterSeason: Season;
    semesterYear: number;
}

export class CreateLectureCommand implements ICreateLectureCommand {
    startDate!: Date;
    endDate!: Date;
    title!: string;
    description!: string;
    /** A CourseId identifier */
    courseId!: string;

    constructor(data?: ICreateLectureCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.courseId = _data["courseId"];
        }
    }

    static fromJS(data: any): CreateLectureCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLectureCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["courseId"] = this.courseId;
        return data;
    }
}

export interface ICreateLectureCommand {
    startDate: Date;
    endDate: Date;
    title: string;
    description: string;
    /** A CourseId identifier */
    courseId: string;
}

export class LectureDto extends BaseResponseOfLectureId implements ILectureDto {
    /** A CourseId identifier */
    courseId!: string;
    startDate!: Date;
    endDate!: Date;
    title!: string;
    description!: string;
    primaryResource!: LecturePrimaryResourceDto | undefined;

    constructor(data?: ILectureDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.courseId = _data["courseId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.primaryResource = _data["primaryResource"] ? LecturePrimaryResourceDto.fromJS(_data["primaryResource"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): LectureDto {
        data = typeof data === 'object' ? data : {};
        let result = new LectureDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["primaryResource"] = this.primaryResource ? this.primaryResource.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ILectureDto extends IBaseResponseOfLectureId {
    /** A CourseId identifier */
    courseId: string;
    startDate: Date;
    endDate: Date;
    title: string;
    description: string;
    primaryResource: LecturePrimaryResourceDto | undefined;
}

export class LecturePrimaryResourceDto extends BaseResponseOfLectureId implements ILecturePrimaryResourceDto {
    presentation!: LectureContentDto | undefined;
    transcription!: TranscriptionDto | undefined;
    media!: LectureContentDto | undefined;

    constructor(data?: ILecturePrimaryResourceDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.presentation = _data["presentation"] ? LectureContentDto.fromJS(_data["presentation"]) : <any>undefined;
            this.transcription = _data["transcription"] ? TranscriptionDto.fromJS(_data["transcription"]) : <any>undefined;
            this.media = _data["media"] ? LectureContentDto.fromJS(_data["media"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): LecturePrimaryResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LecturePrimaryResourceDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["presentation"] = this.presentation ? this.presentation.toJSON() : <any>undefined;
        data["transcription"] = this.transcription ? this.transcription.toJSON() : <any>undefined;
        data["media"] = this.media ? this.media.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ILecturePrimaryResourceDto extends IBaseResponseOfLectureId {
    presentation: LectureContentDto | undefined;
    transcription: TranscriptionDto | undefined;
    media: LectureContentDto | undefined;
}

export abstract class BaseResponseOfLectureContentId implements IBaseResponseOfLectureContentId {
    /** A LectureContentId identifier */
    id!: string;

    constructor(data?: IBaseResponseOfLectureContentId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseResponseOfLectureContentId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponseOfLectureContentId' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseResponseOfLectureContentId {
    /** A LectureContentId identifier */
    id: string;
}

export class LectureContentDto extends BaseResponseOfLectureContentId implements ILectureContentDto {
    created!: Date;
    /** A ResourceId identifier */
    resourceId!: string;
    contentType!: LectureContentType;
    resource!: ResourceResponse;
    name!: string;
    description!: string | undefined;
    isMainContent!: boolean;

    constructor(data?: ILectureContentDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.resourceId = _data["resourceId"];
            this.contentType = _data["contentType"];
            this.resource = _data["resource"] ? ResourceResponse.fromJS(_data["resource"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.isMainContent = _data["isMainContent"];
        }
    }

    static override fromJS(data: any): LectureContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new LectureContentDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["resourceId"] = this.resourceId;
        data["contentType"] = this.contentType;
        data["resource"] = this.resource ? this.resource.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isMainContent"] = this.isMainContent;
        super.toJSON(data);
        return data;
    }
}

export interface ILectureContentDto extends IBaseResponseOfLectureContentId {
    created: Date;
    /** A ResourceId identifier */
    resourceId: string;
    contentType: LectureContentType;
    resource: ResourceResponse;
    name: string;
    description: string | undefined;
    isMainContent: boolean;
}

export enum LectureContentType {
    Video = "Video",
    Audio = "Audio",
    Presentation = "Presentation",
    Document = "Document",
    Other = "Other",
}

export abstract class BaseResponseOfResourceId implements IBaseResponseOfResourceId {
    /** A ResourceId identifier */
    id!: string;

    constructor(data?: IBaseResponseOfResourceId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseResponseOfResourceId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponseOfResourceId' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseResponseOfResourceId {
    /** A ResourceId identifier */
    id: string;
}

export class ResourceResponse extends BaseResponseOfResourceId implements IResourceResponse {
    resourceType!: ResourceType;
    associatedResources!: ResourceResponse[];
    thumbnailResource!: ResourceResponse | undefined;
    fileName!: string;
    mimeType!: string;
    url!: string;
    size!: number;
    order!: number | undefined;

    constructor(data?: IResourceResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resourceType = _data["resourceType"];
            if (Array.isArray(_data["associatedResources"])) {
                this.associatedResources = [] as any;
                for (let item of _data["associatedResources"])
                    this.associatedResources!.push(ResourceResponse.fromJS(item));
            }
            this.thumbnailResource = _data["thumbnailResource"] ? ResourceResponse.fromJS(_data["thumbnailResource"]) : <any>undefined;
            this.fileName = _data["fileName"];
            this.mimeType = _data["mimeType"];
            this.url = _data["url"];
            this.size = _data["size"];
            this.order = _data["order"];
        }
    }

    static override fromJS(data: any): ResourceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceType"] = this.resourceType;
        if (Array.isArray(this.associatedResources)) {
            data["associatedResources"] = [];
            for (let item of this.associatedResources)
                data["associatedResources"].push(item.toJSON());
        }
        data["thumbnailResource"] = this.thumbnailResource ? this.thumbnailResource.toJSON() : <any>undefined;
        data["fileName"] = this.fileName;
        data["mimeType"] = this.mimeType;
        data["url"] = this.url;
        data["size"] = this.size;
        data["order"] = this.order;
        super.toJSON(data);
        return data;
    }
}

export interface IResourceResponse extends IBaseResponseOfResourceId {
    resourceType: ResourceType;
    associatedResources: ResourceResponse[];
    thumbnailResource: ResourceResponse | undefined;
    fileName: string;
    mimeType: string;
    url: string;
    size: number;
    order: number | undefined;
}

export enum ResourceType {
    Media = 0,
    Flag = 1,
    Empty = 2,
    Document = 3,
    Thumbnail = 4,
}

export abstract class BaseResponseOfTranscriptId implements IBaseResponseOfTranscriptId {
    /** A TranscriptId identifier */
    id!: string;

    constructor(data?: IBaseResponseOfTranscriptId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseResponseOfTranscriptId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponseOfTranscriptId' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseResponseOfTranscriptId {
    /** A TranscriptId identifier */
    id: string;
}

export class TranscriptionDto extends BaseResponseOfTranscriptId implements ITranscriptionDto {
    created!: Date;
    items!: TranscriptionItemDto[];
    summary!: string | undefined;
    language!: string;
    transcriptText!: string;

    constructor(data?: ITranscriptionDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TranscriptionItemDto.fromJS(item));
            }
            this.summary = _data["summary"];
            this.language = _data["language"];
            this.transcriptText = _data["transcriptText"];
        }
    }

    static override fromJS(data: any): TranscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TranscriptionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["summary"] = this.summary;
        data["language"] = this.language;
        data["transcriptText"] = this.transcriptText;
        super.toJSON(data);
        return data;
    }
}

export interface ITranscriptionDto extends IBaseResponseOfTranscriptId {
    created: Date;
    items: TranscriptionItemDto[];
    summary: string | undefined;
    language: string;
    transcriptText: string;
}

export abstract class BaseResponseOfTranscriptItemId implements IBaseResponseOfTranscriptItemId {
    /** A TranscriptItemId identifier */
    id!: string;

    constructor(data?: IBaseResponseOfTranscriptItemId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseResponseOfTranscriptItemId {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponseOfTranscriptItemId' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseResponseOfTranscriptItemId {
    /** A TranscriptItemId identifier */
    id: string;
}

export class TranscriptionItemDto extends BaseResponseOfTranscriptItemId implements ITranscriptionItemDto {
    from!: string;
    to!: string;
    text!: string;

    constructor(data?: ITranscriptionItemDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.text = _data["text"];
        }
    }

    static override fromJS(data: any): TranscriptionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TranscriptionItemDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["text"] = this.text;
        super.toJSON(data);
        return data;
    }
}

export interface ITranscriptionItemDto extends IBaseResponseOfTranscriptItemId {
    from: string;
    to: string;
    text: string;
}

export class LectureContentListDto implements ILectureContentListDto {
    contents!: LectureContentDto[];

    constructor(data?: ILectureContentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(LectureContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LectureContentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LectureContentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILectureContentListDto {
    contents: LectureContentDto[];
}

export class UpdateLectureContentCommandContent implements IUpdateLectureContentCommandContent {
    /** A LectureContentId identifier */
    lectureContentId!: string;
    name!: string | undefined;
    description!: string | undefined;
    isMainContent!: boolean | undefined;

    constructor(data?: IUpdateLectureContentCommandContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lectureContentId = _data["lectureContentId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isMainContent = _data["isMainContent"];
        }
    }

    static fromJS(data: any): UpdateLectureContentCommandContent {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLectureContentCommandContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lectureContentId"] = this.lectureContentId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isMainContent"] = this.isMainContent;
        return data;
    }
}

export interface IUpdateLectureContentCommandContent {
    /** A LectureContentId identifier */
    lectureContentId: string;
    name: string | undefined;
    description: string | undefined;
    isMainContent: boolean | undefined;
}

export class FilteredQuery implements IFilteredQuery {
    pageNumber!: number | undefined;
    pageSize!: number | undefined;
    orderBy!: string | undefined;

    constructor(data?: IFilteredQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.orderBy = _data["orderBy"];
        }
    }

    static fromJS(data: any): FilteredQuery {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["orderBy"] = this.orderBy;
        return data;
    }
}

export interface IFilteredQuery {
    pageNumber: number | undefined;
    pageSize: number | undefined;
    orderBy: string | undefined;
}

export class FilteredListOfResourceResponse extends FilteredQuery implements IFilteredListOfResourceResponse {
    items!: ResourceResponse[];
    totalPages!: number;
    totalCount!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IFilteredListOfResourceResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResourceResponse.fromJS(item));
            }
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static override fromJS(data: any): FilteredListOfResourceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FilteredListOfResourceResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        super.toJSON(data);
        return data;
    }
}

export interface IFilteredListOfResourceResponse extends IFilteredQuery {
    items: ResourceResponse[];
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}